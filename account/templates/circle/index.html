{% extends 'account/main.html' %} {% block content %} {% load static %}
<!--<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.11.0.css" />-->
<!--<script src="http://code.jquery.com/qunit/qunit-1.11.0.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tomik23/circular-progress-bar@latest/docs/circularProgressBar.min.js"></script>

<style>
  body {
    font-size: small;
    font-family: "Lato";
    font-style: normal;
  }
  canvas {
    cursor: pointer;
    border: 1px solid black;
    background-color: #fff;
    max-width: 528px;
    max-height:264px;
    width:100%;
  }

  .dot-overlap {
    height: 12px;
    width: 12px;
    background-color: #f38cac;
    border-radius: 50%;
  }

  .dot-total {
    height: 12px;
    width: 12px;
    background-color: #2195f2;
    border-radius: 50%;
  }

  .dot-hit {
    height: 12px;
    width: 12px;
    background-color: #6f6af8;
    border-radius: 50%;
  }

  .dot-untouched {


    height: 12px;
width: 12px;
background-color: #e94f99;
border-radius: 50%;
  }

  .dot-even {
    height: 10px;
    width: 10px;
    background-color: #53989c;
    border-radius: 50%;
    display: inline-block;
    margin-right: 10px;
  }

  .dot-odd {
    height: 10px;
    width: 10px;
    background-color: #a750d4;
    border-radius: 50%;
    display: inline-block;
    margin-right: 10px;
  }

  .flex {
    display: flex;
  }

  .container {
    flex-wrap: wrap;
    justify-content: center;
    max-width: 100%;
    margin: auto;
  }

  .well-canva {
    margin-top: 60px;
    margin-bottom: 170px;
  }
  section {
    padding: 10px;
  }

  [data-pie-index="1"] {
    position: relative;
    border-radius: 50%;
    box-shadow: inset 0 0 25px 10px #a2caff;
  }
  .list-name ul {
    list-style: none;
    margin-top: 10px;
  }

  .list-name ul li {
    text-align: center;
    color: #333;
    font-size: 20px;
    padding-left: 1em;
    text-indent: -1em;
  }
  .heading-circles {
    font-weight: 700;
    font-size: 20px;
    line-height: 24px;
  }

  .canvas-axis {
    font-weight: 700;
    font-size: 20px;
    line-height: 24px;

    /* identical to box height */
    display: flex;
    align-items: center;

    color: #333333;
  }

  .wells-count {
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;

    /* identical to box height */
    display: flex;
    justify-content: end;

    color: #131313;
    float: right;
  }
  .x-axis {
    /* font-family: "Lato";
    font-style: normal; */
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;
    color: #131313;
    position: absolute;
    left: -38px;
  }

  .x-axis-bottom {
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;
    color: #131313;
    position: absolute;
    left: 10px;
    top: 270px;
  }

  .y-axis-bottom {
    position: absolute;
    left: -38px;
    top: 250px;
  }
  .legend-title {
    max-height: 40ch;
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    text-align: center;

    font-weight: 600;
    font-size: 14px;
    color: #131313;
  }
  .legend-title-down {
    font-weight: 600;
    font-size: 14px;
    color: #131313;
    position: absolute;
    top: 270px;
    left: 200px;
  }
  .y-axis {
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;

    position: absolute;
    left: 500px;
    top: 270px;
  }

  .custom-card {
    box-shadow: 0px 4px 20px rgba(22, 22, 22, 0.05);
    border-radius: 16px;
    border: none;
    background-color: #fff;
  }

  .your-canvas-wrapper {
    cursor: not-allowed;
    pointer-events: none;
  }
  .card {
    box-shadow: 0px 4px 20px rgba(22, 22, 22, 0.05);
    border-radius: 16px;
    border: none;
  }
  .animation-class {
    animation: circle-progress 1s ease 0s 1 normal forwards;
  }
  @keyframes heart {
    0% {
      transform: scale(1.07);
    }
    80% {
      transform: scale(1);
    }
    100% {
      transform: scale(0.8);
    }
  }

  @keyframes circle-progress {
    0% {
      transform: scale(0);
    }

    100% {
      transform: scale(1);
    }
  }


  @media (min-width: 768px) and (max-width: 991.98px) {
    .y-axis-bottom{
      position: absolute;
      left: -38px;
      top: 230px;
    }
    .x-axis-bottom {
position: absolute;
left: 10px;
top: 268px;
}


.y-axis {

position: absolute;
left: 500px;
top: 270px;
}
  .legend-title-down {
position: absolute;
top: 265px;
left: 200px;
}

}

@media (max-width: 575.98px) {
.legend-title-down {

   position: absolute;
   top: 120px;
   left: 70px;
 }

 .x-axis-bottom{
      position: absolute;
      left: 0px;
      top: 125px;
    }

    .y-axis-bottom{
      position: absolute;
      left: -38px;
      top: 110px;
    }
     .y-axis {


    position: absolute;
    left: 210px;
    top: 125px;
  }
}

</style>
{% comment %} Start circle intersection Library {% endcomment %}

<script>
  (function (circleIntersection) {
    "use strict";
    var SMALL = 1e-10;
    /** Returns the intersection area of a bunch of circles (where each circle
     is an object having an x,y and radius property) */
    circleIntersection.intersectionArea = function (circles, stats) {
      // get all the intersection points of the circles
      var intersectionPoints =
        circleIntersection.getIntersectionPoints(circles);

      // filter out points that aren't included in all the circles
      var innerPoints = intersectionPoints.filter(function (p) {
        return circleIntersection.containedInCircles(p, circles);
      });

      var arcArea = 0,
        polygonArea = 0,
        arcs = [],
        i;

      // if we have intersection points that are within all the circles,
      // then figure out the area contained by them
      if (innerPoints.length > 1) {
        // sort the points by angle from the center of the polygon, which lets
        // us just iterate over points to get the edges
        var center = circleIntersection.getCenter(innerPoints);
        for (i = 0; i < innerPoints.length; ++i) {
          var p = innerPoints[i];
          p.angle = Math.atan2(p.x - center.x, p.y - center.y);
        }
        innerPoints.sort(function (a, b) {
          return b.angle - a.angle;
        });

        // iterate over all points, get arc between the points
        // and update the areas
        var p2 = innerPoints[innerPoints.length - 1];
        for (i = 0; i < innerPoints.length; ++i) {
          var p1 = innerPoints[i];

          // polygon area updates easily ...
          polygonArea += (p2.x + p1.x) * (p1.y - p2.y);

          // updating the arc area is a little more involved
          var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 },
            arc = null;

          for (var j = 0; j < p1.parentIndex.length; ++j) {
            if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
              // figure out the angle halfway between the two points
              // on the current circle
              var circle = circles[p1.parentIndex[j]],
                a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);

              var angleDiff = a2 - a1;
              if (angleDiff < 0) {
                angleDiff += 2 * Math.PI;
              }

              // and use that angle to figure out the width of the
              // arc
              var a = a2 - angleDiff / 2,
                width = circleIntersection.distance(midPoint, {
                  x: circle.x + circle.radius * Math.sin(a),
                  y: circle.y + circle.radius * Math.cos(a),
                });

              // pick the circle whose arc has the smallest width
              if (arc === null || arc.width > width) {
                arc = { circle: circle, width: width, p1: p1, p2: p2 };
              }
            }
          }
          arcs.push(arc);
          arcArea += circleIntersection.circleArea(
            arc.circle.radius,
            arc.width
          );
          p2 = p1;
        }
      } else {
        // no intersection points, is either disjoint - or is completely
        // overlapped. figure out which by examining the smallest circle
        var smallest = circles[0];
        for (i = 1; i < circles.length; ++i) {
          if (circles[i].radius < smallest.radius) {
            smallest = circles[i];
          }
        }

        // make sure the smallest circle is completely contained in all
        // the other circles
        var disjoint = false;
        for (i = 0; i < circles.length; ++i) {
          if (
            circleIntersection.distance(circles[i], smallest) >
            Math.abs(smallest.radius - circles[i].radius)
          ) {
            disjoint = true;
            break;
          }
        }

        if (disjoint) {
          arcArea = polygonArea = 0;
        } else {
          arcArea = smallest.radius * smallest.radius * Math.PI;
          arcs.push({
            circle: smallest,
            p1: { x: smallest.x, y: smallest.y + smallest.radius },
            p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
            width: smallest.radius * 2,
          });
        }
      }

      polygonArea /= 2;
      if (stats) {
        stats.area = arcArea + polygonArea;
        stats.arcArea = arcArea;
        stats.polygonArea = polygonArea;
        stats.arcs = arcs;
        stats.innerPoints = innerPoints;
        stats.intersectionPoints = intersectionPoints;
      }

      return arcArea + polygonArea;
    };

    /** returns a monte carlo estimate of the overlap of a bunch of circles
     much simpler method than the one above, but slower and less accurate */
    circleIntersection.monteCarloEstimate = function (circles, count) {
      count = count || 10000;
      var contained = 0;
      var bound = circleIntersection.getBoundingRectangle(circles);
      for (var i = 0; i < count; ++i) {
        var p = circleIntersection.randomPoint(bound);
        if (circleIntersection.containedInCircles(p, circles)) {
          contained++;
        }
      }
      return (bound.width * bound.height * contained) / count;
    };

    circleIntersection.subdivideRectangle = function (current, output) {
      var w = current.width / 2,
        h = current.height / 2,
        level = current.level || 0;

      output({
        x: current.x,
        y: current.y,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x + w,
        y: current.y,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x,
        y: current.y + h,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x + w,
        y: current.y + h,
        width: w,
        height: h,
        level: level + 1,
      });
    };

    circleIntersection.rectangleContained = function (current, circles) {
      var x = current.x,
        y = current.y,
        w = current.width,
        h = current.height;

      var pointValues = [
        circleIntersection.containedInCircles({ x: x, y: y }, circles),
        circleIntersection.containedInCircles({ x: x + w, y: y }, circles),
        circleIntersection.containedInCircles({ x: x, y: y + h }, circles),
        circleIntersection.containedInCircles({ x: x + w, y: y + h }, circles),
      ];

      for (var i = 1; i < pointValues.length; ++i) {
        if (pointValues[i] !== pointValues[0]) {
          return 0;
        }
      }

      return pointValues[0] ? 1 : -1;
    };

    circleIntersection.quadtreeEstimate = function (circles, depth) {
      var bound = circleIntersection.getBoundingRectangle(circles),
        area = 0,
        outsideArea = 0;

      if (bound.widh <= 0 || bound.height <= 0) {
        return [0, 0];
      }

      depth = depth || 8;

      function examineRectangle(r) {
        var inOrOut = circleIntersection.rectangleContained(r, circles);
        if (inOrOut === 0) {
          if (r.level <= depth) {
            circleIntersection.subdivideRectangle(r, examineRectangle);
          }
        } else if (inOrOut > 0) {
          area += r.width * r.height;
        } else {
          outsideArea += r.width * r.height;
        }
      }

      bound.level = 0;
      circleIntersection.subdivideRectangle(bound, examineRectangle);

      var uncertain = (bound.width * bound.height - area - outsideArea) / 2;
      return [area + uncertain, uncertain];
    };

    /** returns whether a point is contained by all of a list of circles */
    circleIntersection.containedInCircles = function (point, circles) {
      for (var i = 0; i < circles.length; ++i) {
        if (
          circleIntersection.distance(point, circles[i]) >
          circles[i].radius + SMALL
        ) {
          return false;
        }
      }
      return true;
    };

    /** Gets all intersection points between a bunch of circles */
    circleIntersection.getIntersectionPoints = function (circles) {
      var ret = [];
      for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
          var intersect = circleIntersection.circleCircleIntersection(
            circles[i],
            circles[j]
          );
          for (var k = 0; k < intersect.length; ++k) {
            var p = intersect[k];
            p.parentIndex = [i, j];
            ret.push(p);
          }
        }
      }
      return ret;
    };

    circleIntersection.circleIntegral = function (r, x) {
      var y = Math.sqrt(r * r - x * x);
      return x * y + r * r * Math.atan2(x, y);
    };

    /** Returns the area of a circle of radius r - up to width */
    circleIntersection.circleArea = function (r, width) {
      return (
        circleIntersection.circleIntegral(r, width - r) -
        circleIntersection.circleIntegral(r, -r)
      );
    };

    /** euclidean distance between two points */
    circleIntersection.distance = function (p1, p2) {
      return Math.sqrt(
        (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)
      );
    };

    /** Returns the overlap area of two circles of radius r1 and r2 - that
    have their centers separated by distance d. Simpler faster
    circle intersection for only two circles */
    circleIntersection.circleOverlap = function (r1, r2, d) {
      // no overlap
      if (d >= r1 + r2) {
        return 0;
      }

      // completly overlapped
      if (d <= Math.abs(r1 - r2)) {
        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
      }

      var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
      return (
        circleIntersection.circleArea(r1, w1) +
        circleIntersection.circleArea(r2, w2)
      );
    };

    /** Given two circles (containing a x/y/radius attributes),
    returns the intersecting points if possible.
    note: doesn't handle cases where there are infinitely many
    intersection poiints (circles are equivalent):, or only one intersection point*/
    circleIntersection.circleCircleIntersection = function (p1, p2) {
      var d = circleIntersection.distance(p1, p2),
        r1 = p1.radius,
        r2 = p2.radius;

      // if to far away, or self contained - can't be done
      if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
        return [];
      }

      var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
        h = Math.sqrt(r1 * r1 - a * a),
        x0 = p1.x + (a * (p2.x - p1.x)) / d,
        y0 = p1.y + (a * (p2.y - p1.y)) / d,
        rx = -(p2.y - p1.y) * (h / d),
        ry = -(p2.x - p1.x) * (h / d);

      return [
        { x: x0 + rx, y: y0 - ry },
        { x: x0 - rx, y: y0 + ry },
      ];
    };

    /** Returns the center of a bunch of points */
    circleIntersection.getCenter = function (points) {
      var center = { x: 0, y: 0 };
      for (var i = 0; i < points.length; ++i) {
        center.x += points[i].x;
        center.y += points[i].y;
      }
      center.x /= points.length;
      center.y /= points.length;
      return center;
    };

    circleIntersection.randomPoint = function (rect) {
      return {
        x: rect.x + Math.random() * rect.width,
        y: rect.y + Math.random() * rect.height,
      };
    };

    circleIntersection.getBoundingRectangle = function (circles) {
      function contained(p) {
        return circleIntersection.containedInCircles(p, circles);
      }
      var intersectionPoints =
        circleIntersection.getIntersectionPoints(circles);
      var inner = intersectionPoints.filter(contained);

      var x1 = Math.min.apply(
          null,
          inner.map(function (p) {
            return p.x;
          })
        ),
        y1 = Math.min.apply(
          null,
          inner.map(function (p) {
            return p.y;
          })
        ),
        x2 = Math.max.apply(
          null,
          inner.map(function (p) {
            return p.x;
          })
        ),
        y2 = Math.max.apply(
          null,
          inner.map(function (p) {
            return p.y;
          })
        );

      for (var i = 0; i < circles.length; ++i) {
        var p = circles[i];
        if (p.x - p.radius < x1 && contained({ x: p.x - p.radius, y: p.y })) {
          x1 = p.x - p.radius;
        }
        if (p.x + p.radius > x2 && contained({ x: p.x + p.radius, y: p.y })) {
          x2 = p.x + p.radius;
        }
        if (p.y - p.radius < y1 && contained({ y: p.y - p.radius, x: p.x })) {
          y1 = p.y - p.radius;
        }
        if (p.y + p.radius > y2 && contained({ y: p.y + p.radius, x: p.x })) {
          y2 = p.y + p.radius;
        }
      }

      return { x: x1, y: y1, height: y2 - y1, width: x2 - x1 };
    };
  })((window.circleIntersection = window.circleIntersection || {}));
</script>
{% comment %} End circle intersection Library {% endcomment %}
<script>


// This array hold all the circles on the canvas.
let circles = [];
let idCounter = 0;
let canvas;
let context;
let canvasArea = 0;
let untouchedCanvasArea = 0;
let untouchedCanvasAreaPercentage = 100;
let hitAreaPercentage = 0;
let hitOnceAreaPercentage = 100;
let overlapAreaPercentage = 0;
let overlaps = []
let overlapsNew = []
var totalHitOnceArea = 0;

let multipleOverlapCircles = [];
let multipleOverlapCirclesArea = 0;

this.selectedCircle;
var totalCircles = 0;
var numberOfHorizontalCircles = 3;
var numberOfVerticalCircles = 2;
var numberOfSections = numberOfHorizontalCircles * numberOfVerticalCircles;
var width = 528;
var height = 264;
var R = Math.sqrt(((width * height) / numberOfSections))/2
var R = 30

var circleArr = []


let untouched = null;
let hit = null;
let overlap = null;
let hitareaonce = null;
let untouchedelements = null;
let untouchedcircle = null;
let hitelements = null;
let hitcircle = null;
let overlapelements = null;
let overlapcircle = null;

var translatePos = {};
var scale = 1.0;

// This function stores the details for a single circle.
    function Circle(id, x, y, radius, color, area, row) {
     this.id = id;
     this.x = x;
     this.y = y;
     this.radius = radius;
     this.color = color;
     this.area = area;
     this.isSelected = false;
     this.row = row;
    }

    function CircleAdjustedFix(x, y, radius, area) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.area = area;
    }

   {% comment %} window.onload = function () {
     this.init();
   }; {% endcomment %}
   function initCirclesArray(){
      totalCircles = numberOfVerticalCircles * numberOfHorizontalCircles;
      let rowNumber = 0;

      var rowSize = 0;
      for(let k=0; k < numberOfVerticalCircles; k++){
          var rowArray = []

          for(let i=0; i < numberOfHorizontalCircles; i++){
              rowArray.push(rowSize+i+1);
          }

          rowSize = numberOfHorizontalCircles;
          circleArr[rowNumber] =  rowArray;
          rowNumber++;
      }
  }
  function init() {
    initCirclesArray();

     canvas = document.getElementById("canvas");

     context = canvas.getContext("2d");


     context.clearRect(0, 0, 528, 264);
     circles = [];
     canvasArea = canvas.height * canvas.width;
     untouchedCanvasArea = canvasArea;
     canvas.onmousedown = canvasClick;
     canvas.onmouseup = stopDragging;
     canvas.onmouseout = stopDragging;
     canvas.onmousemove = dragCircle;
     console.log("Total Area: ", canvasArea);
     console.log("Untouched Area: ", untouchedCanvasArea);
     console.log("Radius: ", R);
     var MX = numberOfHorizontalCircles; // max amount of sqares that can fit on the width
     var MY = numberOfVerticalCircles; // max amount of sqares that can fit on the height
     var skipLast = 0;
     var numOfCalculatedCircles = MX * MY;
     if (numOfCalculatedCircles != numberOfSections) {
       if (numOfCalculatedCircles < numberOfSections) {
         //console.log("numOfCalculatedCircles", numOfCalculatedCircles);
         MX = MX + Math.ceil((numberOfSections - numOfCalculatedCircles) / MY);
         if (MX * MY != numberOfSections) {
           skipLast = Math.abs(MX * MY - numberOfSections);
         }
       } else {
         skipLast = numOfCalculatedCircles - numberOfSections;
       }
     }
     // recalculate the radius for X
     if (R * 2 * MX > width) {
       R = width / 2 / MX;
     }

     // recalculate the radius for Y
     if (R * 2 * MY > height) {
       R = height / 2 / MY;
     }

     var circlesWidth = R * 2 * MX;
     var circlesHeight = R * 2 * MY;

     //console.log(circlesWidth, circlesHeight);
     var marginX = 0;
     var marginY = 0;
     if (circlesWidth < width) {
       marginX = (width - circlesWidth) / 2;
     }
     if (circlesHeight < height) {
       marginY = (height - circlesHeight) / 2;
     }
     //console.log(marginX, marginY);

     var centers = [];
     var RY = marginY + R;

     for (var i = 0; i < MY; i++) {
       var RX = marginX + R;
       for (var j = 0; j < MX; j++) {
         if (i === MY - 1) {
           if (j === MX - skipLast) {
             break;
           }
         }
         centers.push({
           x: RX,
           y: RY,
         });
         addRandomCircle(RX, RY, R, i);
         RX += 2 * R;
       }

       RY += 2 * R;
     }
   }



  function addRandomCircle(RX, RY, R, row) {
      idCounter += 1;
      let radius =  R;
      let x = RX;
      let y = RY;

      let color = "#E2E9FB";

      let circle = new Circle(idCounter, x, y, radius, color, parseInt(radius * radius * 3.14,10), row+1);
      circles.push(circle);

      for(var row in circleArr){
            for(var column in circleArr[row]){
                for(var columnAgain in circleArr[row]){
                    if(column != columnAgain){
                        var cirlceIndex = circleArr[row][column]-1;
                        var cirlceIndexAgain = circleArr[row][columnAgain]-1;
                        if(circles[cirlceIndex] && circles[cirlceIndexAgain]){
                            var tempCircles = [circles[cirlceIndex], circles[cirlceIndexAgain]];
                            if (isCircleIntersect(tempCircles)) {
                                var intersectionCoverageArea = overlapMarginLossFunction(circleIntersection.intersectionArea(tempCircles), tempCircles);
                                overlaps[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = intersectionCoverageArea;
                                if(column > columnAgain){
                                    overlapsNew[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = intersectionCoverageArea;
                                }else{
                                    overlapsNew[circleArr[row][column] + "-" + circleArr[row][columnAgain]] = intersectionCoverageArea;
                                }
                            } else {
                                overlaps[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = 0;
                                if(column > columnAgain){
                                    overlapsNew[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = 0;
                                }else{
                                    overlapsNew[circleArr[row][column] + "-" + circleArr[row][columnAgain]] = 0;
                                }
                            }
                        }
                    }
                }
            }

        }

      drawCircles();
      calculateUntouchedArea();
    }

   function clearCanvas() {
     circles = [];

     drawCircles();
   }

   function drawCircles() {
     context.clearRect(0, 0, canvas.width, canvas.height);

     let evenCounter = 2;
     let oddCounter = evenCounter + 1;

     for (let i = 0; i < circles.length; i++) {
       let circle = circles[i];

       context.globalAlpha = 0.25;
       context.beginPath();
       context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);

       context.fillStyle = circle.color;
       if (circle.row == 1) {
        context.strokeStyle = "#1A4893";
      } else {
        context.strokeStyle = "";
      }

       if (circle.isSelected) {
         context.lineWidth = 3;
       } else {
         context.lineWidth = 1;
       }
       context.fill();
       context.stroke();

       context.globalAlpha = 0.85;
       context.beginPath();
       context.arc(circle.x, circle.y, 8, 0, Math.PI * 2);

       if (circle.row == 1) {
        context.fillStyle = "#53989c";
      } else {
        context.fillStyle = "#9932CC";
      }
       //context.strokeStyle = "black";
       context.fill();
       //context.stroke();

       context.beginPath();

       let text = "";

       if (circle.row == 1) {
         text += evenCounter + "HWCA";
         evenCounter += 2;
       } else {
         text += oddCounter + "HWCB";
         oddCounter += 2;
       }

       context.font = "7pt Arial";
       context.fillStyle = "black";
       context.textAlign = "center";
       context.fillText(text, circle.x, circle.y - 13);
     }
   }

   function detactOverlap(){
    //console.log("previousSelectedCircle", previousSelectedCircle)

        if (previousSelectedCircle && previousSelectedCircle.isSelected) {

            for(var row in circleArr){
                for(var column in circleArr[row]){
                    for(var columnAgain in circleArr[row]){
                        if(column != columnAgain){
                            var cirlceIndex = circleArr[row][column]-1;
                            var cirlceIndexAgain = circleArr[row][columnAgain]-1;
                            var tempCircles = [circles[cirlceIndex], circles[cirlceIndexAgain]];
                            var isIntersect = isCircleIntersect(tempCircles);

                            if (isIntersect) {
                                var intersectionCoverageArea = overlapMarginLossFunction(circleIntersection.intersectionArea(tempCircles), tempCircles);
                                overlaps[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = intersectionCoverageArea;
                                if(column > columnAgain){
                                    overlapsNew[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = intersectionCoverageArea;
                                }else{
                                    overlapsNew[circleArr[row][column] + "-" + circleArr[row][columnAgain]] = intersectionCoverageArea;
                                }

                            } else {
                                overlaps[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = 0;
                                if(column > columnAgain){
                                    overlapsNew[circleArr[row][columnAgain] + "-" + circleArr[row][column]] = 0;
                                }else{
                                    overlapsNew[circleArr[row][column] + "-" + circleArr[row][columnAgain]] = 0;
                                }
                            }

                            calculateUntouchedArea(previousSelectedCircle);
                        }
                    }
                }

            }
        }
    }

   function calculateUntouchedArea(previousSelectedCircle){
    untouchedCanvasArea = canvasArea;
    untouchedCanvasAreaPercentage = 100;
    var circleAreaCovered = 0;
    var totalCircleArea = 0;
    var totalOverlapArea = 0;
    for(let i=0; i<circles.length; i++) {
        let circleExist = circles[i];
        circleAreaCovered += circleExist.area
    }
    totalCircleArea = circleAreaCovered;

    let overlapArea = 0;
    for (var key in overlaps) {
        overlapArea += overlaps[key];
    }

    let hitArea = 0;
    for (var key in overlapsNew) {
        hitArea += overlapsNew[key];
    }


    if(hitArea > 0){
        circleAreaCovered -=  hitArea;
    }

    var rowsOverlapAreas = [];

    if(circles.length == totalCircles){
        rowsOverlapAreas = [];
        for(var row in circleArr){
            var rowCircles = []
            for(var column in circleArr[row]){
                var circleIndex = circleArr[row][column]-1;
                var circleElement = circles[circleIndex];
                var dummyAdjust = "0.000000" + "" + column;
                var circleAdjustedX = circleElement.x + parseFloat(dummyAdjust);
                var circleAdjusted = new CircleAdjustedFix(circleAdjustedX, circleElement.y, circleElement.radius, circleElement.area);
                rowCircles.push(circleAdjusted)
            }
            var rowOverlapArea = 0;
            rowOverlapArea = overlapMarginLossFunction(circleIntersection.intersectionArea(rowCircles), rowCircles);
            if(rowOverlapArea > 0){
                rowsOverlapAreas.push(rowOverlapArea);
            }
        }
    }


    let circleOverlapAdjustment = 0;
    for(var eachRowOverlap in rowsOverlapAreas){
        circleOverlapAdjustment +=  rowsOverlapAreas[eachRowOverlap];
    }
    if(circleOverlapAdjustment > 0){
        circleAreaCovered += circleOverlapAdjustment;

        totalOverlapArea = overlapArea;

        totalOverlapArea -= circleOverlapAdjustment * numberOfHorizontalCircles;

    } else {
        totalOverlapArea = overlapArea;
    }

    totalHitOnceArea = totalCircleArea - totalOverlapArea;

    hitOnceAreaPercentage = Math.round(getPercentage(totalHitOnceArea, totalCircleArea).toFixed(2));

    hitAreaPercentage = Math.round(getPercentage(circleAreaCovered, canvasArea).toFixed(2));

    overlapAreaPercentage = Math.round(getPercentage(totalOverlapArea, totalCircleArea).toFixed(2));

    untouchedCanvasArea -= circleAreaCovered;
    untouchedCanvasAreaPercentage = Math.round(getPercentage(untouchedCanvasArea, canvasArea).toFixed(2));

    console.log("Total Area: ", canvasArea);
    console.log("Total Circle Area: ", (totalCircleArea).toFixed(2));

    console.log("Hit Area: ", circleAreaCovered.toFixed(2));
    console.log("Hit Area Percentage: ", hitAreaPercentage);

    console.log("Area Once: ", (totalHitOnceArea).toFixed(2));
    console.log("Area Once Percentage: ", (hitOnceAreaPercentage));

    console.log("Overlap Area: ", (totalOverlapArea).toFixed(2));
    console.log("Overlap Area Percentage: ", overlapAreaPercentage);

    console.log("Untouched Area: ", untouchedCanvasArea.toFixed(2));
    console.log("Untouched Area Percentage: ", untouchedCanvasAreaPercentage);


    $(".lbl-total-area" ).html(new Intl.NumberFormat('en-US').format(canvasArea * 100));
    $(".lbl-hit-area" ).html(new Intl.NumberFormat('en-US').format((circleAreaCovered * 100).toFixed(0)));
    $(".lbl-hit-once" ).html(new Intl.NumberFormat('en-US').format((totalHitOnceArea * 100).toFixed(0)));
    $(".lbl-overlap-area" ).html(new Intl.NumberFormat('en-US').format((totalOverlapArea * 100).toFixed(0))) ;
    $(".lbl-untouched-area" ).html(new Intl.NumberFormat('en-US').format((untouchedCanvasArea* 100).toFixed(0)) );

    /* ASIF Code Start
    const radius =  R*10
    const TotalArea =  canvasArea * 100
    const OneCircleArea =  oneCircleArea * 100
    const HitAllArea =  ((circleAreaCovered * 100).toFixed(0))
    const HitAllAreaPercentage =  hitAreaPercentage
    const HitOnceArea = (hitAreaOnce * 100).toFixed(0)
    const HitOnceAreaPercentage = hitAreaOncePercentage
    const OverlapArea = overlapArea.toFixed(2)  * 100
    const OverlapAreaPercentage = overlapAreaPercentage
    const UntouchedArea = (untouchedCanvasArea* 100).toFixed(0)
    const UntouchedAreaPercentage = untouchedCanvasAreaPercentage



    $.ajax({
      url: "/",
      type: "POST",
      data: {
        radius: radius,
        TotalArea: TotalArea,
        OneCircleArea: OneCircleArea,
        HitAllArea: HitAllArea,
        HitAllAreaPercentage: HitAllAreaPercentage,
        HitOnceArea: HitOnceArea,
        HitOnceAreaPercentage: HitOnceAreaPercentage,
        OverlapArea: OverlapArea,
        OverlapAreaPercentage: OverlapAreaPercentage,
        UntouchedArea: UntouchedArea,
        UntouchedAreaPercentage: UntouchedAreaPercentage,
      },
      contentType: "application/json",
      dataType: "json",
      success: function (data) {
        console.log(data)
      },
      error: function (data) {
        console.log("error:")
      }
  });

    /* ASIF Code End */


    if(untouched != null){

      untouched.forEach((el, index) => {

         const options = {
           index: index + 1,
           percent: untouchedCanvasAreaPercentage,
         };
         untouchedcircle.animationTo(options);
       });

       setTimeout(() => {
        const options = {
          index: 1,
          percent: untouchedCanvasAreaPercentage,
        };
        untouchedcircle.animationTo(options);
      }, 2000);

    }
    if(hit != null){

        console.log("hitAreaPercentage",hitAreaPercentage)
       hit.forEach((el, index) => {
        const options = {
         index: index + 1,
          percent: hitAreaPercentage,
        };
        hitcircle.animationTo(options);
      });
      setTimeout(() => {
        const options = {
          index: 1,
          percent: hitAreaPercentage,
        };
        hitcircle.animationTo(options);
      }, 2000);
    }

    if(hitareaonce != null){

    console.log("hitOnceAreaPercentage",hitOnceAreaPercentage)
      hitareaonce.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: hitOnceAreaPercentage,
        };
        hitareaoncecircle.animationTo(options);
      });

      setTimeout(() => {
        const options = {
          index: 1,
          percent: hitOnceAreaPercentage,
        };
        hitareaoncecircle.animationTo(options);
      }, 2000)

    }

    if(overlap != null){

      console.log("overlapAreaPercentage",overlapAreaPercentage)
      overlap.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: overlapAreaPercentage,
        };
        overlapcircle.animationTo(options);
      });

      setTimeout(() => {
        const options = {
          index: 1,
          percent: overlapAreaPercentage,
        };
        overlapcircle.animationTo(options);
      }, 2000)

     }


   }

   function overlapMarginLossFunction(overlapArea, circles){
      var leastCircleArea = circles[0].area;
      for (var key in circles) {
          if(circles[key].area < leastCircleArea)
              leastCircleArea = circles[key].area;
      }

      if(leastCircleArea < overlapArea){
          overlapArea = leastCircleArea;
      }
      return overlapArea;
  }

  function getPercentage(number, total){
      return (number/total)*100
  }

  function isCircleIntersect(circlesArray) {
      return overlapMarginLossFunction(circleIntersection.intersectionArea(circlesArray), circlesArray) > 0 ? true : false;
  }


   let previousSelectedCircle;

   function canvasClick(e) {
     let clickX = e.pageX - canvas.offsetLeft;
     let clickY = e.pageY - canvas.offsetTop;

     for (let i = circles.length - 1; i >= 0; i--) {
       let circle = circles[i];

       let distanceFromCenter = Math.sqrt(
         Math.pow(circle.x - clickX, 2) + Math.pow(circle.y - clickY, 2)
       );
       if (distanceFromCenter <= circle.radius) {
         if (previousSelectedCircle != null)
           previousSelectedCircle.isSelected = false;
         previousSelectedCircle = circle;

         circle.isSelected = true;

         isDragging = true;
         this.selectedCircle = circle;

         drawCircles();
         return;
       }
     }
   }

   let isDragging = false;

   function stopDragging() {
     isDragging = false;
   }

   function dragCircle(e) {
     if (isDragging == true) {
       if (previousSelectedCircle != null) {
         let x = e.pageX - canvas.offsetLeft;
         //let y = e.pageY - canvas.offsetTop;
         if (x < R) {
           x = R;
         }

         if (x > canvas.width - R) {
           x = canvas.width - R;
         }
         previousSelectedCircle.x = x;
         //previousSelectedCircle.y = y;

         drawCircles();
         detactOverlap();
       }
     }
   }

   function randomFromTo(from, to) {
     return Math.floor(Math.random() * (to - from + 1) + from);
   }

   window.addEventListener("DOMContentLoaded", () => {
     this.init();
     untouched = document.querySelectorAll(".untouched");
     hit = document.querySelectorAll(".hit");
     hitareaonce = document.querySelectorAll(".hitareaonce");
     overlap = document.querySelectorAll(".overlap");

     // start the animation when the element is in the page view

     const untouchedConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#E94F99",
      colorCircle: "#F0F5FB",
      round: true
    };
     untouchedcircle = new CircularProgressBar("untouched",untouchedConfig);
     untouchedcircle.initial();

     const hitcircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: " #6F6AF8",
      colorCircle: "#F0F5FB",
      round: true
    };
     hitcircle = new CircularProgressBar("hit",hitcircleConfig);
     hitcircle.initial();

     const hitareaoncecircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#F38CAC",
      colorCircle: "#F0F5FB",
      round: true
    };
    hitareaoncecircle = new CircularProgressBar("hitareaonce",hitareaoncecircleConfig);
    hitareaoncecircle.initial();

     const overlapcircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#2195f2",
      colorCircle: "#F0F5FB",
      round: true,

    };

     overlapcircle = new CircularProgressBar("overlap",overlapcircleConfig);
     overlapcircle.initial();


     untouched.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: untouchedCanvasAreaPercentage,
        };
        untouchedcircle.animationTo(options);
      });


    console.log("hitAreaPercentage",hitAreaPercentage)

      hit.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: hitAreaPercentage,
      };
      hitcircle.animationTo(options);
    });

    hitareaonce.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: hitOnceAreaPercentage,
      };
      hitareaoncecircle.animationTo(options);
    });

    overlap.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: overlapAreaPercentage,
      };
      overlapcircle.animationTo(options);
    });
  // update circle when range change
   });

{% comment %} Asif {% endcomment %}
   /*
   function export2txt() {
    const originalData = {
      area: [{
          totalArea:  canvasArea * 100,
        },

        {
          HitAllAreaPercentage: hitAreaPercentage,

        },
        {
          HitOnceAreaPercentage: hitAreaOncePercentage,

        },
        {
          UntouchedArea: (untouchedCanvasArea* 100).toFixed(0),
        },
        {
          UntouchedAreaPrectage: untouchedCanvasAreaPercentage,
        }
      ]
    };
      const a = document.createElement("a");
      a.href = URL.createObjectURL(new Blob([JSON.stringify(originalData, null, 2)], {
      type: "text/plain"
      }));
      a.setAttribute("download", "data.txt");
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
  }
  */

</script>
<body>
  <div class="container mb-2" style="margin-top: 70px">
    <div class="row">
      <div class="col-sm-12 col-md-12 col-lg-8 col-xl-9 col-xxl-9 custom-card">
        <div class="container">
          <p class="canvas-axis mt-5">Wine Rack View</p>
  {% comment %} <button onclick="export2txt()">Export data to local txt file</button> {% endcomment %}

          <p
            class=""
            style="
              float: right;
              font-family: 'Lato';
              font-style: normal;
              font-weight: 600;
              font-size: 14px;
              line-height: 17px;
            "
          >
            No of Wells : 6
          </p>
          <div class="d-flex justify-content-center mt-5 mb-5">
            <fieldset style="position: relative; width: 106px" class="d-none d-lg-block">
              <legend
                style="
                  position: absolute;
                  font-family: 'Lato';
                  font-style: normal;
                  font-weight: 400;
                  font-size: 12px;
                  line-height: 14px;
                  left: 70px;
                "
              >
                7000’
              </legend>
              <legend
                style="
                  position: absolute;
                  font-family: 'Lato';
                  font-style: normal;
                  font-weight: 400;
                  font-size: 12px;
                  line-height: 14px;
                  left: 70px;
                  top: 255px;
                "
              >
                9640’
              </legend>
              <legend
                style="
                  position: absolute;
                  font-family: 'Lato';
                  font-style: normal;
                  font-weight: 400;
                  font-size: 12px;
                  line-height: 14px;
                  left: 607px;
                  top: 268px;
                "
              >
                5280’
              </legend>
              <legend
                style="
                  position: absolute;
                  top: 90px;
                  max-height: 40ch;
                  writing-mode: vertical-rl;
                  transform: rotate(180deg);
                  text-align: center;
                  font-family: 'Lato';
                  font-style: normal;
                  font-weight: 600;
                  font-size: 14px;
                  color: #131313;
                  left: 80px;
                  width: 0px;
                "
              >
                Depth in Feet
              </legend>
              <legend
                style="
                  position: absolute;
                  top: 268px;
                  width: 100%;
                  text-align: center;
                  font-family: 'Lato';
                  font-style: normal;
                  font-weight: 600;
                  font-size: 14px;
                  color: #131313;
                  left: 310px;
                "
              >
                Distance in Feet​
              </legend>
            </fieldset>
            <canvas id="canvas" width="528" height="264" class></canvas>
          </div>
        </div>
      </div>
      <div class="col-sm-12 col-md-12 col-lg-4 col-xl-3 col-xxl-3 mt-4 mt-lg-0 animation-class ">
        <div class="card">
          <p class="heading-circles text-center mt-5">Wells Land Utilization</p>
          <div class="row mx-3 mb-5">
            <section
              class="list-name col-sm-6"
              style="justify-content: center; display: grid"
            >
              <div class="hit mx-3" data-pie='{ "percent": 0}'></div>

              <div class="flex mt-1">
                <span class="dot-hit mt-1"></span>
                <p class="FracArea mx-1">Total Simulated Area</p>
              </div>
            </section>
            <section
              class="list-name col-sm-6"
              style="justify-content: center; display: grid"
            >
              <div
                class="hitareaonce"
                data-pie='{ "percent": 0, "fontWeight": 100 }'
              ></div>
              <div class="flex mt-2">
                <span class="dot-overlap mt-1"></span>
                <p class="FracArea mx-1">Area Hit Once</p>
              </div>
            </section>
            <section
            class="list-name col-sm-6"
            style="justify-content: center; display: grid"
          >
        <div
          class="untouched inner"
          data-pie='{ "percent": 0, "fontWeight": 100 }'
        ></div>
        <div class="flex mt-1 mx-2">
          <span class="dot-untouched mt-1"></span>
          <p class="FracArea mx-1">Untouched​</p>
        </div>
      </section>
            <section
              class="list-name col-sm-6"
              style="justify-content: center; display: grid"
            >
              <div
                class="overlap"
                data-pie='{ "percent": 0,"fontWeight": 100 }'
              ></div>
              <div class="flex mt-2 mx-3">
                <span class="dot-total mt-1"></span>
                <p class="FracArea mx-1">Overlap</p>
              </div>
            </section>

          </div>
        </div>
      </div>
    </div>

  </div>
  {% include 'circle/eclipse.html' %}
  {% include 'circle/status.html' %}
  {% endblock content %}
</body>

<script>

</script>