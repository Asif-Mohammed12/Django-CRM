{% extends 'account/main.html' %} 
{% block content %} 
{% load static %}
<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.11.0.css" />
<script src="http://code.jquery.com/qunit/qunit-1.11.0.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/tomik23/circular-progress-bar@latest/docs/circularProgressBar.min.js"></script>

<style>
  body {
    font-size: small;
    font-family: "Lato";
    font-style: normal;
  }
  canvas {
    cursor: pointer;
    border: 1px solid #002060;
    background-color: #fff;
  }

  .dot-overlap {
    height: 12px;
    width: 12px;
    background-color: #2195f2;
    border-radius: 50%;
  }

  .dot-total {
    height: 12px;
    width: 12px;
    background-color: #2595F0;
    border-radius: 50%;
  }

  .dot-hit {
    height: 12px;
    width: 12px;
    background-color: #e94f99;
    border-radius: 50%;
  }

  .dot-untouched {
    height: 12px;
    width: 12px;
    background-color: #6f6af8;
    border-radius: 50%;
  }

  .dot-even {
    height: 10px;
    width: 10px;
    background-color: #53989c;
    border-radius: 50%;
    display: inline-block;
    margin-right: 10px;
  }

  .dot-odd {
    height: 10px;
    width: 10px;
    background-color: #a750d4;
    border-radius: 50%;
    display: inline-block;
    margin-right: 10px;
  }

  .flex {
    display: flex;
  }

  .container {
    flex-wrap: wrap;
    justify-content: center;
    max-width: 100%;
    margin: auto;
  }

  .well-canva {
    margin-top: 60px;
    margin-bottom: 170px;
  }
  section {
    padding: 10px;
  }

  [data-pie-index="1"] {
    position: relative;
    border-radius: 50%;
    box-shadow: inset 0 0 25px 10px #a2caff;
  }
  .list-name ul {
    list-style: none;
    margin-top: 10px;
  }

  .list-name ul li {
    text-align: center;
    color: #333;
    font-size: 20px;
    padding-left: 1em;
    text-indent: -1em;
  }
  .heading-circles {
    font-weight: 700;
    font-size: 20px;
    line-height: 24px;
  }

  .canvas-axis {
    font-weight: 700;
    font-size: 20px;
    line-height: 24px;

    /* identical to box height */
    display: flex;
    align-items: center;

    color: #333333;
  }

  .wells-count {
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;

    /* identical to box height */
    display: flex;
    align-items: center;

    color: #131313;
    float: right;
  }
  .x-axis {
    /* font-family: "Lato";
    font-style: normal; */
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;
    color: #131313;
    position: absolute;
    left: -38px;
  }

  .x-axis-bottom {
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;
    color: #131313;
    position: absolute;
    left: 10px;
    top: 270px;
  }

  .y-axis-bottom {
    position: absolute;
    left: -38px;
    top: 250px;
  }
  .legend-title {
    max-height: 40ch;
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    text-align: center;

    font-weight: 600;
    font-size: 14px;
    color: #131313;
  }
  .legend-title-down {
    font-weight: 600;
    font-size: 14px;
    color: #131313;
    position: absolute;
    top: 270px;
    left: 200px;
  }
  .y-axis {
    font-weight: 400;
    font-size: 12px;
    line-height: 14px;

    position: absolute;
    left: 500px;
    top: 270px;
  }

  .custom-card {
    box-shadow: 0px 4px 20px rgba(22, 22, 22, 0.05);
    border-radius: 16px;
    border: none;
    background-color: #fff;
  }

  .your-canvas-wrapper {
    cursor: not-allowed;
    pointer-events: none;
  }
  .card {
    box-shadow: 0px 4px 20px rgba(22, 22, 22, 0.05);
    border-radius: 16px;
    border: none;
  }
  .animation-class {
    animation: circle-progress 1s ease 0s 1 normal forwards;
  }
  @keyframes heart {
    0% {
      transform: scale(1.07);
    }
    80% {
      transform: scale(1);
    }
    100% {
      transform: scale(0.8);
    }
  }

  @keyframes circle-progress {
    0% {
      transform: scale(0);
    }

    100% {
      transform: scale(1);
    }
  }
</style>
<script>
  (function (circleIntersection) {
    "use strict";
    var SMALL = 1e-10;
    /** Returns the intersection area of a bunch of circles (where each circle
     is an object having an x,y and radius property) */
    circleIntersection.intersectionArea = function (circles, stats) {
      // get all the intersection points of the circles
      var intersectionPoints =
        circleIntersection.getIntersectionPoints(circles);

      // filter out points that aren't included in all the circles
      var innerPoints = intersectionPoints.filter(function (p) {
        return circleIntersection.containedInCircles(p, circles);
      });

      var arcArea = 0,
        polygonArea = 0,
        arcs = [],
        i;

      // if we have intersection points that are within all the circles,
      // then figure out the area contained by them
      if (innerPoints.length > 1) {
        // sort the points by angle from the center of the polygon, which lets
        // us just iterate over points to get the edges
        var center = circleIntersection.getCenter(innerPoints);
        for (i = 0; i < innerPoints.length; ++i) {
          var p = innerPoints[i];
          p.angle = Math.atan2(p.x - center.x, p.y - center.y);
        }
        innerPoints.sort(function (a, b) {
          return b.angle - a.angle;
        });

        // iterate over all points, get arc between the points
        // and update the areas
        var p2 = innerPoints[innerPoints.length - 1];
        for (i = 0; i < innerPoints.length; ++i) {
          var p1 = innerPoints[i];

          // polygon area updates easily ...
          polygonArea += (p2.x + p1.x) * (p1.y - p2.y);

          // updating the arc area is a little more involved
          var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 },
            arc = null;

          for (var j = 0; j < p1.parentIndex.length; ++j) {
            if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
              // figure out the angle halfway between the two points
              // on the current circle
              var circle = circles[p1.parentIndex[j]],
                a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);

              var angleDiff = a2 - a1;
              if (angleDiff < 0) {
                angleDiff += 2 * Math.PI;
              }

              // and use that angle to figure out the width of the
              // arc
              var a = a2 - angleDiff / 2,
                width = circleIntersection.distance(midPoint, {
                  x: circle.x + circle.radius * Math.sin(a),
                  y: circle.y + circle.radius * Math.cos(a),
                });

              // pick the circle whose arc has the smallest width
              if (arc === null || arc.width > width) {
                arc = { circle: circle, width: width, p1: p1, p2: p2 };
              }
            }
          }
          arcs.push(arc);
          arcArea += circleIntersection.circleArea(
            arc.circle.radius,
            arc.width
          );
          p2 = p1;
        }
      } else {
        // no intersection points, is either disjoint - or is completely
        // overlapped. figure out which by examining the smallest circle
        var smallest = circles[0];
        for (i = 1; i < circles.length; ++i) {
          if (circles[i].radius < smallest.radius) {
            smallest = circles[i];
          }
        }

        // make sure the smallest circle is completely contained in all
        // the other circles
        var disjoint = false;
        for (i = 0; i < circles.length; ++i) {
          if (
            circleIntersection.distance(circles[i], smallest) >
            Math.abs(smallest.radius - circles[i].radius)
          ) {
            disjoint = true;
            break;
          }
        }

        if (disjoint) {
          arcArea = polygonArea = 0;
        } else {
          arcArea = smallest.radius * smallest.radius * Math.PI;
          arcs.push({
            circle: smallest,
            p1: { x: smallest.x, y: smallest.y + smallest.radius },
            p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
            width: smallest.radius * 2,
          });
        }
      }

      polygonArea /= 2;
      if (stats) {
        stats.area = arcArea + polygonArea;
        stats.arcArea = arcArea;
        stats.polygonArea = polygonArea;
        stats.arcs = arcs;
        stats.innerPoints = innerPoints;
        stats.intersectionPoints = intersectionPoints;
      }

      return arcArea + polygonArea;
    };

    /** returns a monte carlo estimate of the overlap of a bunch of circles
     much simpler method than the one above, but slower and less accurate */
    circleIntersection.monteCarloEstimate = function (circles, count) {
      count = count || 10000;
      var contained = 0;
      var bound = circleIntersection.getBoundingRectangle(circles);
      for (var i = 0; i < count; ++i) {
        var p = circleIntersection.randomPoint(bound);
        if (circleIntersection.containedInCircles(p, circles)) {
          contained++;
        }
      }
      return (bound.width * bound.height * contained) / count;
    };

    circleIntersection.subdivideRectangle = function (current, output) {
      var w = current.width / 2,
        h = current.height / 2,
        level = current.level || 0;

      output({
        x: current.x,
        y: current.y,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x + w,
        y: current.y,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x,
        y: current.y + h,
        width: w,
        height: h,
        level: level + 1,
      });

      output({
        x: current.x + w,
        y: current.y + h,
        width: w,
        height: h,
        level: level + 1,
      });
    };

    circleIntersection.rectangleContained = function (current, circles) {
      var x = current.x,
        y = current.y,
        w = current.width,
        h = current.height;

      var pointValues = [
        circleIntersection.containedInCircles({ x: x, y: y }, circles),
        circleIntersection.containedInCircles({ x: x + w, y: y }, circles),
        circleIntersection.containedInCircles({ x: x, y: y + h }, circles),
        circleIntersection.containedInCircles({ x: x + w, y: y + h }, circles),
      ];

      for (var i = 1; i < pointValues.length; ++i) {
        if (pointValues[i] !== pointValues[0]) {
          return 0;
        }
      }

      return pointValues[0] ? 1 : -1;
    };

    circleIntersection.quadtreeEstimate = function (circles, depth) {
      var bound = circleIntersection.getBoundingRectangle(circles),
        area = 0,
        outsideArea = 0;

      if (bound.widh <= 0 || bound.height <= 0) {
        return [0, 0];
      }

      depth = depth || 8;

      function examineRectangle(r) {
        var inOrOut = circleIntersection.rectangleContained(r, circles);
        if (inOrOut === 0) {
          if (r.level <= depth) {
            circleIntersection.subdivideRectangle(r, examineRectangle);
          }
        } else if (inOrOut > 0) {
          area += r.width * r.height;
        } else {
          outsideArea += r.width * r.height;
        }
      }

      bound.level = 0;
      circleIntersection.subdivideRectangle(bound, examineRectangle);

      var uncertain = (bound.width * bound.height - area - outsideArea) / 2;
      return [area + uncertain, uncertain];
    };

    /** returns whether a point is contained by all of a list of circles */
    circleIntersection.containedInCircles = function (point, circles) {
      for (var i = 0; i < circles.length; ++i) {
        if (
          circleIntersection.distance(point, circles[i]) >
          circles[i].radius + SMALL
        ) {
          return false;
        }
      }
      return true;
    };

    /** Gets all intersection points between a bunch of circles */
    circleIntersection.getIntersectionPoints = function (circles) {
      var ret = [];
      for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
          var intersect = circleIntersection.circleCircleIntersection(
            circles[i],
            circles[j]
          );
          for (var k = 0; k < intersect.length; ++k) {
            var p = intersect[k];
            p.parentIndex = [i, j];
            ret.push(p);
          }
        }
      }
      return ret;
    };

    circleIntersection.circleIntegral = function (r, x) {
      var y = Math.sqrt(r * r - x * x);
      return x * y + r * r * Math.atan2(x, y);
    };

    /** Returns the area of a circle of radius r - up to width */
    circleIntersection.circleArea = function (r, width) {
      return (
        circleIntersection.circleIntegral(r, width - r) -
        circleIntersection.circleIntegral(r, -r)
      );
    };

    /** euclidean distance between two points */
    circleIntersection.distance = function (p1, p2) {
      return Math.sqrt(
        (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)
      );
    };

    /** Returns the overlap area of two circles of radius r1 and r2 - that
    have their centers separated by distance d. Simpler faster
    circle intersection for only two circles */
    circleIntersection.circleOverlap = function (r1, r2, d) {
      // no overlap
      if (d >= r1 + r2) {
        return 0;
      }

      // completly overlapped
      if (d <= Math.abs(r1 - r2)) {
        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
      }

      var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
      return (
        circleIntersection.circleArea(r1, w1) +
        circleIntersection.circleArea(r2, w2)
      );
    };

    /** Given two circles (containing a x/y/radius attributes),
    returns the intersecting points if possible.
    note: doesn't handle cases where there are infinitely many
    intersection poiints (circles are equivalent):, or only one intersection point*/
    circleIntersection.circleCircleIntersection = function (p1, p2) {
      var d = circleIntersection.distance(p1, p2),
        r1 = p1.radius,
        r2 = p2.radius;

      // if to far away, or self contained - can't be done
      if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
        return [];
      }

      var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
        h = Math.sqrt(r1 * r1 - a * a),
        x0 = p1.x + (a * (p2.x - p1.x)) / d,
        y0 = p1.y + (a * (p2.y - p1.y)) / d,
        rx = -(p2.y - p1.y) * (h / d),
        ry = -(p2.x - p1.x) * (h / d);

      return [
        { x: x0 + rx, y: y0 - ry },
        { x: x0 - rx, y: y0 + ry },
      ];
    };

    /** Returns the center of a bunch of points */
    circleIntersection.getCenter = function (points) {
      var center = { x: 0, y: 0 };
      for (var i = 0; i < points.length; ++i) {
        center.x += points[i].x;
        center.y += points[i].y;
      }
      center.x /= points.length;
      center.y /= points.length;
      return center;
    };

    circleIntersection.randomPoint = function (rect) {
      return {
        x: rect.x + Math.random() * rect.width,
        y: rect.y + Math.random() * rect.height,
      };
    };

    circleIntersection.getBoundingRectangle = function (circles) {
      function contained(p) {
        return circleIntersection.containedInCircles(p, circles);
      }
      var intersectionPoints =
        circleIntersection.getIntersectionPoints(circles);
      var inner = intersectionPoints.filter(contained);

      var x1 = Math.min.apply(
          null,
          inner.map(function (p) {
            return p.x;
          })
        ),
        y1 = Math.min.apply(
          null,
          inner.map(function (p) {
            return p.y;
          })
        ),
        x2 = Math.max.apply(
          null,
          inner.map(function (p) {
            return p.x;
          })
        ),
        y2 = Math.max.apply(
          null,
          inner.map(function (p) {
            return p.y;
          })
        );

      for (var i = 0; i < circles.length; ++i) {
        var p = circles[i];
        if (p.x - p.radius < x1 && contained({ x: p.x - p.radius, y: p.y })) {
          x1 = p.x - p.radius;
        }
        if (p.x + p.radius > x2 && contained({ x: p.x + p.radius, y: p.y })) {
          x2 = p.x + p.radius;
        }
        if (p.y - p.radius < y1 && contained({ y: p.y - p.radius, x: p.x })) {
          y1 = p.y - p.radius;
        }
        if (p.y + p.radius > y2 && contained({ y: p.y + p.radius, x: p.x })) {
          y2 = p.y + p.radius;
        }
      }

      return { x: x1, y: y1, height: y2 - y1, width: x2 - x1 };
    };
  })((window.circleIntersection = window.circleIntersection || {}));
</script>
<script>
   // This function stores the details for a single circle.
   function Circle(id, x, y, radius, color, area, row) {
     this.id = id;
     this.x = x;
     this.y = y;
     this.radius = radius;
     this.color = color;
     this.area = area;
     this.isSelected = false;
     this.row = row;
   }

   // This array hold all the circles on the canvas.
   let circles = [];
   let idCounter = 0;
   let canvas;
   let context;
   let canvasArea = 0;

   let untouchedCanvasArea = 0;
   let untouchedCanvasAreaPercentage = 100;
   let hitAreaPercentage = 100;
   let overlapAreaPercentage = 0;
   let overlaps = [];

   let multipleOverlapCircles = [];
   let multipleOverlapCirclesArea = 0;

   this.selectedCircle;

   var numberOfHorizontalCircles = 3;
   var numberOfVerticalCircles = 2;
   var numberOfSections = numberOfHorizontalCircles * numberOfVerticalCircles;
   var width = 528;
   var height = 264;
   var R = Math.sqrt(((width * height) / numberOfSections))/2;
   var R = 30;

   let untouched = null;
   let hit = null;
   let overlap = null;
   let untouchedelements = null;
   let untouchedcircle = null;
   let hitelements = null;
   let hitcircle = null;
   let overlapelements = null;
   let overlapcircle = null;

   var translatePos = {};
   var scale = 1.0;


   {% comment %} window.onload = function () {
     this.init();
   }; {% endcomment %}

   function init() {
     canvas = document.getElementById("canvas");

     context = canvas.getContext("2d");


     context.clearRect(0, 0, 528, 264);
     circles = [];
     canvasArea = canvas.height * canvas.width;
     untouchedCanvasArea = canvasArea;
     canvas.onmousedown = canvasClick;
     canvas.onmouseup = stopDragging;
     canvas.onmouseout = stopDragging;
     canvas.onmousemove = dragCircle;
     console.log("Total Area: ", canvasArea);
     console.log("Untouched Area: ", untouchedCanvasArea);
     console.log("Radius: ", R);
     var MX = numberOfHorizontalCircles; // max amount of sqares that can fit on the width
     var MY = numberOfVerticalCircles; // max amount of sqares that can fit on the height
     var skipLast = 0;
     var numOfCalculatedCircles = MX * MY;
     if (numOfCalculatedCircles != numberOfSections) {
       if (numOfCalculatedCircles < numberOfSections) {
         //console.log("numOfCalculatedCircles", numOfCalculatedCircles);
         MX = MX + Math.ceil((numberOfSections - numOfCalculatedCircles) / MY);
         if (MX * MY != numberOfSections) {
           skipLast = Math.abs(MX * MY - numberOfSections);
         }
       } else {
         skipLast = numOfCalculatedCircles - numberOfSections;
       }
     }
     // recalculate the radius for X
     if (R * 2 * MX > width) {
       R = width / 2 / MX;
     }

     // recalculate the radius for Y
     if (R * 2 * MY > height) {
       R = height / 2 / MY;
     }

     var circlesWidth = R * 2 * MX;
     var circlesHeight = R * 2 * MY;

     //console.log(circlesWidth, circlesHeight);
     var marginX = 0;
     var marginY = 0;
     if (circlesWidth < width) {
       marginX = (width - circlesWidth) / 2;
     }
     if (circlesHeight < height) {
       marginY = (height - circlesHeight) / 2;
     }
     //console.log(marginX, marginY);

     var centers = [];
     var RY = marginY + R;

     for (var i = 0; i < MY; i++) {
       var RX = marginX + R;
       for (var j = 0; j < MX; j++) {
         if (i === MY - 1) {
           if (j === MX - skipLast) {
             break;
           }
         }
         centers.push({
           x: RX,
           y: RY,
         });
         addRandomCircle(RX, RY, R, i);
         RX += 2 * R;
       }

       RY += 2 * R;
     }
   }

   function addRandomCircle(RX, RY, R, i) {
     idCounter += 1;
     let radius = R;
     let x = RX;
     let y = RY;

     let color = "#E2E9FB";

     let circle = new Circle(
       idCounter,
       x,
       y,
       radius,
       color,
       parseInt(radius * radius * 3.14, 10),
       i + 1
     );

     for (let i = 0; i < circles.length; i++) {
       let circleExist = circles[i];
       if (
         circleIntersect(
           circleExist.x,
           circleExist.y,
           circleExist.radius,
           circle.x,
           circle.y,
           circle.radius
         )
       ) {
         if (circleExist.id > circle.id) {
           overlaps[circle.id + "-" + circleExist.id] = intersectionArea(
             circleExist.x,
             circleExist.y,
             circleExist.radius,
             circle.x,
             circle.y,
             circle.radius
           );
         } else {
           overlaps[circleExist.id + "-" + circle.id] = intersectionArea(
             circleExist.x,
             circleExist.y,
             circleExist.radius,
             circle.x,
             circle.y,
             circle.radius
           );
         }
       }
     }

     circles.push(circle);
     calculateUntouchedArea();

     drawCircles();
   }

   function clearCanvas() {
     circles = [];

     drawCircles();
   }

   function drawCircles() {
     context.clearRect(0, 0, canvas.width, canvas.height);

     let evenCounter = 2;
     let oddCounter = evenCounter + 1;

     for (let i = 0; i < circles.length; i++) {
       let circle = circles[i];

       context.globalAlpha = 0.25;
       context.beginPath();
       context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);

       context.fillStyle = circle.color;
       if (circle.row == 1) {
        context.strokeStyle = "#1A4893";
      } else {
        context.strokeStyle = "";
      }

       if (circle.isSelected) {
         context.lineWidth = 3;
       } else {
         context.lineWidth = 1;
       }
       context.fill();
       context.stroke();

       context.globalAlpha = 0.85;
       context.beginPath();
       context.arc(circle.x, circle.y, 8, 0, Math.PI * 2);

       if (circle.row == 1) {
        context.fillStyle = "#53989c";
      } else {
        context.fillStyle = "#9932CC";
      }
       //context.strokeStyle = "black";
       context.fill();
       //context.stroke();

       context.beginPath();

       let text = "";

       if (circle.row == 1) {
         text += evenCounter + "HWCA";
         evenCounter += 2;
       } else {
         text += oddCounter + "HWCB";
         oddCounter += 2;
       }

       context.font = "7pt Arial";
       context.fillStyle = "black";
       context.textAlign = "center";
       context.fillText(text, circle.x, circle.y - 13);
     }
   }

   function detactOverlap() {
     //console.log("previousSelectedCircle", previousSelectedCircle)

     if (previousSelectedCircle && previousSelectedCircle.isSelected) {
       for (let i = 0; i < circles.length; i++) {
         if (previousSelectedCircle.id == circles[i].id) {
           // let circle = circles[i];
           // context.globalAlpha = 0.85;
           // context.beginPath();
           // context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
           // context.fillStyle = circle.color;
           // context.strokeStyle = "red";
           // context.fill();
           // context.stroke();
         } else {
           let circle = circles[i];
           // context.globalAlpha = 0.85;
           // context.beginPath();
           // context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
           // context.fillStyle = circle.color;

           if (
             circleIntersect(
               previousSelectedCircle.x,
               previousSelectedCircle.y,
               previousSelectedCircle.radius,
               circle.x,
               circle.y,
               circle.radius
             )
           ) {
             // context.strokeStyle = "red";
             // console.log("overlapping")
             // context.moveTo( previousSelectedCircle.x + previousSelectedCircle.radius, previousSelectedCircle.y );
             // context.arc(previousSelectedCircle.x, previousSelectedCircle.y, previousSelectedCircle.radius, 0, Math.PI*2);
             // context.fillStyle = previousSelectedCircle.color;
             // context.strokeStyle = "red";

             //console.log(previousSelectedCircle.id + "-" +   circle.id, intersectionArea(previousSelectedCircle.x, previousSelectedCircle.y, previousSelectedCircle.radius, circle.x, circle.y, circle.radius))
             //console.log(previousSelectedCircle.id + "-" +   circle.id, getPercentage(intersectionArea(previousSelectedCircle.x, previousSelectedCircle.y, previousSelectedCircle.radius, circle.x, circle.y, circle.radius), circle.area))

             if (previousSelectedCircle.id > circle.id) {
               overlaps[circle.id + "-" + previousSelectedCircle.id] =
                 intersectionArea(
                   previousSelectedCircle.x,
                   previousSelectedCircle.y,
                   previousSelectedCircle.radius,
                   circle.x,
                   circle.y,
                   circle.radius
                 );
             } else {
               overlaps[previousSelectedCircle.id + "-" + circle.id] =
                 intersectionArea(
                   previousSelectedCircle.x,
                   previousSelectedCircle.y,
                   previousSelectedCircle.radius,
                   circle.x,
                   circle.y,
                   circle.radius
                 );
             }
             context.strokeStyle = "red";
             calculateUntouchedArea(previousSelectedCircle);
           } else {
             if (previousSelectedCircle.id > circle.id) {
               overlaps[circle.id + "-" + previousSelectedCircle.id] = 0;
             } else {
               overlaps[previousSelectedCircle.id + "-" + circle.id] = 0;
             }
             calculateUntouchedArea(previousSelectedCircle);
             //context.strokeStyle = "black";
           }
           // context.fill();
           // context.stroke();
         }
       }
     }
   }

   function calculateUntouchedArea(previousSelectedCircle) {
     untouchedCanvasArea = canvasArea;
     untouchedCanvasAreaPercentage = 100;
     var circleAreaCovered = 0;
     var oneCircleArea = 0;
     var totalCircleArea = 0;
     for (let i = 0; i < circles.length; i++) {
       let circleExist = circles[i];
       circleAreaCovered += circleExist.area;
       totalCircleArea += circleExist.area;
       oneCircleArea = circleExist.area;
       //console.log("circleExist", circleExist.area);
     }

     let overlapArea = 0;
     for (var key in overlaps) {
       overlapArea += overlaps[key];
     }

     //console.log("Hit Area without Overlap: ", circleAreaCovered);

     if (overlapArea > 0) {
       //console.log("overlaps", overlaps);
       circleAreaCovered -= overlapArea;
     }

     let circlesNew = [];
     let ii = 0;

     for (let k = 0; k < numberOfVerticalCircles; k++) {
       let rowNumber = k + 1;
       if (multipleOverlapCircles.length == 0) {
         multipleOverlapCircles[k] = 0;
       }
       for (let i = 0; i < circles.length; i++) {
         if (
           previousSelectedCircle &&
           previousSelectedCircle.isSelected &&
           previousSelectedCircle.row == rowNumber &&
           circles[i].row == rowNumber
         ) {
           circlesNew[ii] = circles[i];
           ii++;
           multipleOverlapCircles[k] =
             circleIntersection.intersectionArea(circlesNew);
         }
       }
     }

     //console.log("Overlap Area Adjustment: ", multipleOverlapCircles);

     let circleOverlapAdjustment = 0;
     if (multipleOverlapCircles.length > 0) {
       for (let k = 0; k < multipleOverlapCircles.length; k++) {
         circleOverlapAdjustment += multipleOverlapCircles[k];
       }
     }

     if (circleOverlapAdjustment > 0) {
       circleAreaCovered += circleOverlapAdjustment;
       // console.log("Overlap Area Total Adjustment: ", circleOverlapAdjustment);
     }
     hitAreaPercentage = getPercentage(circleAreaCovered, canvasArea).toFixed(2);

     hitAreaOnce = totalCircleArea - overlapArea;
     var hitAreaOnceDisplayPercent = totalCircleArea - overlapArea;
     hitAreaOncePercentage = getPercentage(hitAreaOnce, totalCircleArea).toFixed(2);

     overlapAreaPercentage = getPercentage(overlapArea, totalCircleArea).toFixed(2);
     // console.log("Hit Area: ", circleAreaCovered);
     if (circleAreaCovered > 0) {
       untouchedCanvasAreaPercentage -= getPercentage(
         circleAreaCovered,
         untouchedCanvasArea
       );
       untouchedCanvasArea -= circleAreaCovered;
     }


     //console.log("Overlap Area: ", overlapArea);

     //console.log("Untouched Area: ", untouchedCanvasArea);
     //console.log("Untouched Area Percentage: ", untouchedCanvasAreaPercentage);
     console.log("Radius: ", R*10);
     $(".radius-dynamic" ).html(new Intl.NumberFormat('en-US').format(R*10));
    console.log("Total Area: ", canvasArea * 100);
    console.log("One Circle Area: ", oneCircleArea * 100);
     console.log("Hit All Area: ", (circleAreaCovered * 100).toFixed(0));
     console.log("Hit All Area Percentage: ", hitAreaPercentage);
     console.log("Hit Once Area: ", (hitAreaOnce * 100).toFixed(0));
     console.log("Hit Once Area Percentage: ", hitAreaOncePercentage);
     console.log("Overlap Area: ", overlapArea.toFixed(2)  * 100);
     console.log("Overlap Area Percentage: ", overlapAreaPercentage);
     console.log("Untouched Area: ", (untouchedCanvasArea* 100).toFixed(0) );
     console.log("Untouched Area Percentage: ", untouchedCanvasAreaPercentage);

     $(".lbl-total-area" ).html(new Intl.NumberFormat('en-US').format(canvasArea * 100));
     $(".lbl-hit-area" ).html(new Intl.NumberFormat('en-US').format((circleAreaCovered * 100).toFixed(0)));
     $(".lbl-hit-once" ).html(new Intl.NumberFormat('en-US').format((hitAreaOnceDisplayPercent * 100).toFixed(0)));
     $(".lbl-overlap-area" ).html(new Intl.NumberFormat('en-US').format((overlapArea * 100).toFixed(0))) ;
     $(".lbl-untouched-area" ).html(new Intl.NumberFormat('en-US').format((untouchedCanvasArea* 100).toFixed(0)) );

     if(untouched != null){
      untouched.forEach((el, index) => {
         const options = {
           index: index + 1,
           percent: untouchedCanvasAreaPercentage,
         };
         untouchedcircle.animationTo(options);
       });

       hit.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: hitAreaPercentage,
        };
        hitcircle.animationTo(options);
      });

      hitareaonce.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: hitAreaOncePercentage,
        };
        hitareaoncecircle.animationTo(options);
      });
      
      overlap.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: overlapAreaPercentage,
        };
        overlapcircle.animationTo(options);
      });

     }


   }

   function getPercentage(number, total) {
     return (number / total) * 100;
   }

   function circleIntersect(x0, y0, r0, x1, y1, r1) {
     return Math.hypot(x0 - x1, y0 - y1) <= r0 + r1;
   }

   let previousSelectedCircle;

   function canvasClick(e) {
     let clickX = e.pageX - canvas.offsetLeft;
     let clickY = e.pageY - canvas.offsetTop;

     for (let i = circles.length - 1; i >= 0; i--) {
       let circle = circles[i];

       let distanceFromCenter = Math.sqrt(
         Math.pow(circle.x - clickX, 2) + Math.pow(circle.y - clickY, 2)
       );
       if (distanceFromCenter <= circle.radius) {
         if (previousSelectedCircle != null)
           previousSelectedCircle.isSelected = false;
         previousSelectedCircle = circle;

         circle.isSelected = true;

         isDragging = true;
         this.selectedCircle = circle;

         drawCircles();
         return;
       }
     }
   }

   function intersectionDots(x0, y0, r0, x1, y1, r1) {
     var a, dx, dy, d, h, rx, ry;
     var x2, y2;
     /* dx and dy are the vertical and horizontal distances between the circle centers. */
     dx = x1 - x0;
     dy = y1 - y0;
     /* Determine the straight-line distance between the centers. */
     d = Math.sqrt(dy * dy + dx * dx);
     /* Check for solvability. */
     if (d > r0 + r1) {
       /* circles do not intersect. */
       return false;
     }
     if (d < Math.abs(r0 - r1)) {
       /* one circle is contained in the other */
       return false;
     }
     /* 'point 2' is the point where the line through the circle intersection points crosses the line between the circle centers.  */
     /* Determine the distance from point 0 to point 2. */
     a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);
     /* Determine the coordinates of point 2. */
     x2 = x0 + (dx * a) / d;
     y2 = y0 + (dy * a) / d;
     /* Determine the distance from point 2 to either of the intersection points. */
     h = Math.sqrt(r0 * r0 - a * a);
     /* Now determine the offsets of the intersection points from point 2. */
     rx = -dy * (h / d);
     ry = dx * (h / d);

     /* Determine the absolute intersection points. */
     var xi = x2 + rx;
     var xi_prime = x2 - rx;
     var yi = y2 + ry;
     var yi_prime = y2 - ry;

     return [xi, xi_prime, yi, yi_prime];
   }

   function intersectionArea(x0, y0, r0, x1, y1, r1) {
     var rr0 = r0 * r0;
     var rr1 = r1 * r1;
     var d = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
     // Circles do not overlap
     if (d > r1 + r0) {
       return 0;
     }
     // Circle1 is completely inside circle0
     else if (d <= Math.abs(r0 - r1) && r0 >= r1) {
       return Math.PI * rr1;
     }
     // Circle0 is completely inside circle1
     else if (d <= Math.abs(r0 - r1) && r0 < r1) {
       return Math.PI * rr0;
     }
     // Circles partially overlap
     else {
       var phi = Math.acos((rr0 + d * d - rr1) / (2 * r0 * d)) * 2;
       var theta = Math.acos((rr1 + d * d - rr0) / (2 * r1 * d)) * 2;
       var area1 = 0.5 * theta * rr1 - 0.5 * rr1 * Math.sin(theta);
       var area2 = 0.5 * phi * rr0 - 0.5 * rr0 * Math.sin(phi);
       // Return area of intersection
       return area1 + area2;
     }
   }

   let isDragging = false;

   function stopDragging() {
     isDragging = false;
   }

   function dragCircle(e) {
     if (isDragging == true) {
       if (previousSelectedCircle != null) {
         let x = e.pageX - canvas.offsetLeft;
         //let y = e.pageY - canvas.offsetTop;
         if (x < R) {
           x = R;
         }

         if (x > canvas.width - R) {
           x = canvas.width - R;
         }
         previousSelectedCircle.x = x;
         //previousSelectedCircle.y = y;

         drawCircles();
         detactOverlap();
       }
     }
   }

   function randomFromTo(from, to) {
     return Math.floor(Math.random() * (to - from + 1) + from);
   }

   window.addEventListener("DOMContentLoaded", () => {
     this.init();
     untouched = document.querySelectorAll(".untouched");
     hit = document.querySelectorAll(".hit");
     hitareaonce = document.querySelectorAll(".hitareaonce");
     overlap = document.querySelectorAll(".overlap");

     // start the animation when the element is in the page view

     const untouchedConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#6F6AF8",
      colorCircle: "#F0F5FB",
      round: true
    };
     untouchedcircle = new CircularProgressBar("untouched",untouchedConfig);
     untouchedcircle.initial();

     const hitcircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#E94F99",
      colorCircle: "#F0F5FB",
      round: true
    };
     hitcircle = new CircularProgressBar("hit",hitcircleConfig);
     hitcircle.initial();

     const hitareaoncecircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#E94F99",
      colorCircle: "#F0F5FB",
      round: true
    };
    hitareaoncecircle = new CircularProgressBar("hitareaonce",hitareaoncecircleConfig);
    hitareaoncecircle.initial();

     const overlapcircleConfig = {
      size: 100,
      speed: 30,
      animationSmooth: "1s ease-out",
      strokeBottom: 5,
      colorSlice: "#2195f2",
      colorCircle: "#F0F5FB",
      round: true,

    };

     overlapcircle = new CircularProgressBar("overlap",overlapcircleConfig);
     overlapcircle.initial();


     untouched.forEach((el, index) => {
        const options = {
          index: index + 1,
          percent: untouchedCanvasAreaPercentage,
        };
        untouchedcircle.animationTo(options);
      });



      hit.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: hitAreaPercentage,
      };
      hitcircle.animationTo(options);
    });

    hitareaonce.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: hitAreaOncePercentage,
      };
      hitareaoncecircle.animationTo(options);
    });

    overlap.forEach((el, index) => {
      const options = {
        index: index + 1,
        percent: overlapAreaPercentage,
      };
      overlapcircle.animationTo(options);
    });
  // update circle when range change
   });
</script>
<body>
  <div class="container mb-2" style="margin-top: 70px">
    <div class="row">
      <div class="col-md-9 custom-card">
        <div class="container">
          <p class="canvas-axis mt-5">Wine Rack View</p>
          <p class="" style="float: right;font-family: 'Lato';
          font-style: normal;
          font-weight: 600;
          font-size: 14px;
          line-height: 17px;">No of Wells : 6</p>
          <div class="d-flex justify-content-center mt-5 mb-5">
             <fieldset style="position:relative;width:106px">
              <legend style="
              position: absolute;
              font-family: 'Lato';
              font-style: normal;
              font-weight: 400;
              font-size: 12px;
              line-height: 14px;
              left: 70px;
              ">
              7000’
            </legend>
            <legend style="
            position: absolute;
            font-family: 'Lato';
            font-style: normal;
            font-weight: 400;
            font-size: 12px;
            line-height: 14px;
            left: 70px;
            top: 255px;
            ">
            9640’
          </legend>
          <legend style="
            position: absolute;
            font-family: 'Lato';
            font-style: normal;
            font-weight: 400;
            font-size: 12px;
            line-height: 14px;
            left: 607px;
            top: 268px;
            ">
            5280’
          </legend>
              <legend style="position: absolute;
              top: 90px;
              max-height: 40ch;
              writing-mode: vertical-rl;
              transform: rotate(180deg);
              text-align: center;
              font-family: 'Lato';
              font-style: normal;
              font-weight: 600;
              font-size: 14px;
              color: #131313;
              left: 80px;">Depth in Feet​:</legend>
              <legend style="position: absolute;
              top: 268px;
              width: 100%;
              text-align: center;
              font-family: 'Lato';
              font-style: normal;
              font-weight: 600;
              font-size: 14px;
              color: #131313;
              left: 310px;"
             >Distance in Feet​</legend>
             </fieldset>
            <canvas id="canvas" width="528" height="264" class></canvas>
           
          </div>
        </div>
      </div>
      <div class="col-md-3 animation-class">
        <div class="card">
          <p class="heading-circles text-center mt-5">
            Wells Land Utilization
          </p>
          <div class="row mx-3 mb-5">
            <section class="list-name col-sm-6" style="justify-content: center;display: grid;">
              <div
                class="untouched inner"
                data-pie='{ "percent": 0, "fontWeight": 100 }'
              ></div>
              <div class="flex mt-2">
                <span class="dot-untouched mt-1"></span>
                <p class="FracArea mx-1">UNTOUCHED</p>
              </div>
            </section>
             <section class="list-name col-sm-6" style="justify-content: center;display: grid;">
             
              <div class="hit" data-pie='{ "percent": 0}'></div>

              <div class="flex mt-2 mx-3">
                <span class="dot-hit mt-1"></span>
                <p class="FracArea mx-1">HIT ALL</p>
              </div>
            </section>
             <section class="list-name col-sm-6" style="justify-content: center;display: grid;">
              <div
              class="hitareaonce"
              data-pie='{ "percent": 0, "fontWeight": 100 }'
            ></div>
              <div class="flex mt-2 mx-3">
                <span class="dot-hit mt-1"></span> 
                <p class="FracArea mx-1">HIT ONCE</p>
              </div>
            </section>
             <section class="list-name col-sm-6" style="justify-content: center;display: grid;">
              <div
                class="overlap"
                data-pie='{ "percent": 0,"fontWeight": 100 }'
              ></div>
              <div class="flex mt-2 mx-3">
                <span class="dot-total mt-1"></span>
             
                <p class="FracArea mx-1">OVERLAP</p>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>
  </div>
  {% include 'circle/eclipse.html' %} 
  {% include 'circle/status.html' %} 
  {% endblock content %}
</body>
